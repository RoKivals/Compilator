# Функциональное программирование: Пишем компилятор!

Цель этой лабораторной работы - придумать свой собственный функциональный язык программирования и разработать для него интерпретатор или компилятор.

Вы можете выполнить эту лабораторную работу в группе из 2 или 3 человек (или больше - но это требует одобрения преподавателя):

* 2 человека - компилятор/интерпретатор + примеры программ + краткая документация в README.md (вы можете заменить этот файл своей собственной документацией)
* 3 человека - компилятор/интерпретатор + примеры программ + более подробная документация на GitHub Pages
* 3 и более человек - помимо вышеуказанного, может включать следующее:
  - IDE в браузере
  - Поддержка Jupyter Notebook
  - Трансляция в JavaScript, чтобы можно было выполнять программу в браузере
  - Расширения для VS Code

## Авторы

Имя | Роль в проекте
------------------|---------------------
Ахатов Тимур | Разработка (Inerpreter)
Орусский Вячесла | Разработка (Compilator)
Петров Илья | Примеры (CodeSample)
Карнаков Никита | Документация

## Задача

Ваша цель - изобрести и реализовать собственный функциональный язык программирования. Требования:

* Он должен тесно следовать парадигме функционального программирования, на основе либо [лямбда-исчисления](https://en.wikipedia.org/wiki/Lambda_calculus), либо [комбинаторной логики](https://en.wikipedia.org/wiki/Combinatory_logic).
* Он должен быть более или менее универсальным, т.е. реализовывать рекурсию. В идеале - полным по Тьюрингу.
* Как минимум, язык должен позволять запрограммировать функцию для расчета факториала.

> Имейте в виду, что написание парсеров - это утомительная задача, поэтому постарайтесь сделать синтаксис языка как можно проще.

Для вдохновения:

* Изучите [LISP](https://books.ifmo.ru/file/pdf/1918.pdf) - язык программирования с очень простым синтаксисом.
* Комбинаторные парсеры и библиотеку [fparsec](https://www.quanttec.com/fparsec/), если вы хотите реализовать язык с более сложным синтаксисом.
* [Top-Down Parser на F#](https://github.com/fholm/Vaughan).
* Интересный блог пост о [парсинге на F#](https://www.erikschierboom.com/2016/12/10/parsing-text-in-fsharp/).
* Парсинг с использованием инструментов [FsLex и FsYacc](https://realfiction.net/posts/lexing-and-parsing-in-f/) (не рекомендуется).
* Реализация [Scheme в F#](https://github.com/AshleyF/FScheme) - вы можете ознакомиться с этим проектом для вдохновения, но не заимствуйте код оттуда!

## Критерии оценки

* Универсальность
* Примеры программ (включая факториал, но не ограничиваясь им)
* Оригинальность и красота синтаксиса
* Документированность
* Красота реализации

Предпочтительный язык реализации - F#.

В документации явно укажите, какие функции языка вы реализовали:

* [x] Именованные переменные (`let`)
* [x] Рекурсия
* [ ] Ленивое вычисление
* [x] Функции
* [ ] Замыкания
* [ ] Библиотечные функции: ввод-вывод файлов вывод
* [x] Списки / Последовательности
* [x] Библиотечные функции: списки/последовательности

# Документация к реализованному языку
### Переменные
Для объявления переменных используется ключевое слово `let`
```f#
let x = 10
```
### Типы
- Bool
- Int
- Float
- List

### Функции
Обычные функции объявляются используя `fun`:
```f#
fun f(a b)
{
  a * b
}
```
Рекурсия `rec`:
```f#
rec fun f(a n res)
{
    if n = 1 then {a * res} else {a * fun(a (n - 1) res)}
}
```

### Условия
```f#
let a = 6
let b = 10
if a - b > 0 then
{
    true
} else
{
    false
}
```

### Списки
```f#
var numbers = [1 2 3 4 5]
var len = 5

fun f(lst n)
{
  if n - 1 >= 0 then
  {
    print(lst[n])
    f(lst n - 1)
  }
  else
  {
    0
  }
}

```

# Документация: Пользовательский Компилятор

## Введение

Данный проект представляет собой реализацию собственного компилятора, написанного на F#. Он включает в себя два основных модуля: **Parser** и **Interpreter**, а также примеры кода, которые демонстрируют работу компилятора.

Компилятор поддерживает базовые конструкции языка программирования, такие как объявления переменных, функции, рекурсивные функции, условные выражения, а также операции с числами и логическими значениями.

Проект содержит следующие компоненты:

- **Parser.fs** – модуль, отвечающий за синтаксический анализ.
- **Interpreter.fs** – модуль интерпретатора, выполняющий код.
- **FSharpCompilV2.fsproj** – файл проекта.
- **CodeSample** – примеры программ для компилятора.
- **.gitignore** – файл, исключающий ненужные файлы из системы контроля версий.

## Parser.fs

### Описание

Модуль **Parser** реализует синтаксический анализатор для компилятора на основе библиотеки **FParsec**. 
Парсер обрабатывает различные синтаксические конструкции языка, такие как функции, рекурсивные функции, операторы, условные выражения и вызовы методов. 
Основная цель парсера — преобразовать исходный код в дерево синтаксического разбора (AST), которое затем передается в интерпретатор для выполнения.

### Основные функции и компоненты

1. **ParseFloat** 
Парсит числа с плавающей запятой, за которыми могут следовать пробелы. Результатом работы парсера является узел AST типа `Float`.
2. **ParseBool**
Парсит булевые значения (`true` или `false`), за которыми могут следовать пробелы. Результатом является узел AST типа `Bool`.
3. **ID**
Парсит идентификаторы, которые могут состоять из букв, цифр и символа `_`. Идентификаторы используются для имен переменных и функций.
4. **Operator** 
Парсит операторы языка, такие как `&&`, `||`, `+`, `-`, `*`, `/` и т.д. Результатом парсера является строковое представление оператора.
5. **Func**
Парсит определение функции. Функция начинается с ключевого слова `fun`, затем идет имя функции, список параметров в круглых скобках и тело функции, заключенное в фигурные скобки. 
Возвращает узел AST типа `Let`, который связывает имя функции с ее определением (лямбдой).
6. **RecursiveFunc**
Аналогично функции `Func`, но используется для парсинга рекурсивных функций, которые объявляются с ключевым словом `rec fun`. 
Возвращает узел AST типа `LetRec`.
7. **Variable**
Парсит объявление переменной, начиная с ключевого слова `var`, затем идет имя переменной и выражение, которому переменная присваивается.
8. **ParseList** – парсер для списков.
9. **ApplicationFunc** – парсер для вызова функций.
10. **Operation**
Парсит бинарные операции между числами, булевыми значениями, переменными или функциями. 
Поддерживаются операторы, такие как `+`,`-`, `*`, `/`, `&&` и другие.
11. **IndexList** – парсер для доступа к элементам списка.
12. **Method** – парсер для методов.
13. **IfThenElse**
Парсит условные выражения вида `if ... then ... else`. Возвращает узел AST типа `IfThenElse`.
14. **ParsePrint**
Парсит команду `print` для вывода значений на экран. Возвращает узел AST типа `Print`.
15. **readFile**
Функция для чтения файла с исходным кодом. Если файл не найден, генерируется ошибка.
16. **main**
Главная функция программы, которая принимает имя файла с исходным кодом, парсит его и выполняет.

**Ошибки**

1. **Неверное имя переменной или функции**: 
Если идентификатор переменной или функции не соответствует правилам синтаксиса, будет выведено сообщение `"Invalid name of func / variable"`.
2. **Неизвестный оператор или неверное выражение**: 
В случае неправильного использования операторов или выражений может возникнуть ошибка, связанная с недопустимой конструкцией в коде.
3. **Ошибка при чтении файла**: 
Если файл не найден, программа завершит работу с сообщением об ошибке.

Парсер также поддерживает вызов рекурсивных функций и операторы, такие как арифметические операции и операции сравнения.

### Использование

Модуль может быть запущен через командную строку, принимая в качестве аргумента файл с кодом для интерпретации. Например:

```
dotnet run примерКода.txt
```

## Interpreter.fs

### Описание

Модуль `Interpreter` предоставляет средства для интерпретации исходного кода, представленного в виде абстрактного синтаксического дерева (AST). Модуль включает поддержку таких конструкций языка, как переменные, функции, условия, операции, рекурсивные функции и другие. 
Главная функция `eval` выполняет выражения в окружении переменных и поддерживает лямбда-функции, примитивные операции, списки и другие типы данных.

### Основные типы

1. **id**  
Тип, представляющий имя переменной или функции (строка).  
2. **expr**  
Тип данных для представления различных выражений языка (например, переменные, функции, булевы значения, числа, условные выражения и т.д.).  
3. **env**  
Тип, представляющий окружение, которое хранит сопоставление переменных с их значениями.  

### Типы выражений (expr)

1. `Variable(id)` - переменная с именем `id`.
2. `Lambda(id list * expr)` - функция, принимающая список аргументов (переменные) и выражение (тело функции).  
3. `Composition(expr * expr)` -  композиция двух выражений.  
4. `Bool(bool)` - булево значение (истина или ложь).  
5. `Int(int)` -  целое число.  
6. `Float(float)` - число с плавающей запятой.  
7. `List(expr list)` - список выражений.  
8. `IfThenElse(expr * expr * expr)` - условное выражение, содержащее условие, ветку "тогда" и ветку "иначе".  
9. `Let(id * expr * expr)` - связывание переменной `id` с выражением в левой части и использование ее в правой части.  
10.`LetRec(id * expr * expr)` - рекурсивное связывание переменной `id` с выражением.  
11. `PrimitiveOperation(id)` - примитивная операция (например, `+`, `-`, `&&`).  
12. `Op(id * int * expr list)` - операция, представляющая собой функцию с аргументами и выражениями.  
13. `Closure(expr * env)` - замыкание, содержащее выражение и окружение.  
14. `RClosure(expr * env * id)` - рекурсивное замыкание.  
15. `Prog(expr list)` - последовательность выражений (программа).  
16. `Print(expr)` - выражение для вывода на экран.  
17. `None` - пустое значение (используется как результат некоторых операций).  

### Основные компоненты

1. **eval**  
Главная функция интерпретатора, которая выполняет выражение `exp` в заданном окружении `env`. Для каждого типа выражения определено, как оно должно интерпретироваться. 
Например, для переменной происходит поиск ее значения в окружении, для условного выражения выполняется проверка условия и выбор нужной ветки.
2. **apply**  
Функция, которая применяется к выражениям в случае вызова функции или замыкания.   
Проверяет количество аргументов, создает новое окружение и передает его в тело функции для выполнения.  
3. **Operation**  
Функция Operation реализует различные операции, такие как логические операции, арифметические действия, операции над списками. 
Для каждой операции функция принимает список аргументов и выполняет соответствующую операцию, проверяя типы аргументов.
**Примеры**  
`[]`: индексация списка.  
`front`: возвращает первый элемент списка.  
`back`: возвращает последний элемент списка.  
`append`: добавляет элемент в конец списка.  
`&&`, `||`, `!`: логические операции.  
`+`, `-`, `*`, `/`, `%`: арифметические операции.  
4. **Let** и **LetRec** – для работы с переменными и рекурсивными функциями.  
5. **IfThenElse** – условные выражения `if-then-else`.  
6. **Print** – вывод значений на экран.  
7. **ArgsNum**  
Функция возвращает количество аргументов для каждой примитивной операции.  
Например, логические операции (`&&`, `||`, `!`) принимают 1 или 2 аргумента, арифметические операции (`+`, `-`, `*`, `/`) принимают 2 аргумента.  

### Обработка ошибок

`type error`: если типы аргументов операции не совпадают с ожидаемыми, выдается ошибка типа.  
`unknown operator error`: ошибка неизвестного оператора.  
`error`: если происходит ошибка при применении функции или замыкания.  
  
### Пример использования

Пример вычисления факториала числа 10:

```
rec fun fact (n) {
    if n = 1 then {1}
    else {
        n * fact (n - 1)
    }
}
print(fact(10))
```

## FSharpCompilV2.fsproj

### Описание

Это файл проекта, используемый в экосистеме .NET для управления сборкой проекта на F#. 
Он определяет, какие исходные файлы нужно компилировать, какие пакеты использовать, и на какую версию .NET ориентироваться. 
Этот файл помогает организовать проект и управлять зависимостями.

### Основное содержание:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <Compile Include="Interpreter.fs" />
    <Compile Include="Parser.fs" />
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="FParsec" Version="1.1.1" />
  </ItemGroup>
</Project>
```

### Основные элементы

1.**Project Sdk="Microsoft.NET.Sdk"**  
Определяет, что проект использует SDK для .NET. В данном случае используется SDK Microsoft.NET.Sdk.  
2.**PropertyGroup**  
<OutputType>Exe</OutputType>: Указывает, что результат сборки будет исполняемым файлом (exe).  
<TargetFramework>net8.0</TargetFramework>: Определяет целевую версию платформы .NET — в данном случае .NET 8.0.  
3. **ItemGroup**  
**Компиляция файлов**  
<Compile Include="Interpreter.fs" />: Указывает, что файл Interpreter.fs должен быть включен в процесс компиляции.  
<Compile Include="Parser.fs" />: Указывает, что файл Parser.fs должен быть включен в процесс компиляции.  
4. **Зависимости (пакеты)**  
<PackageReference Include="FParsec" Version="1.1.1" />:   
Добавляет зависимость на пакет `FParsec` версии 1.1.1. `FParsec` — это библиотека для парсинга и обработки текста на F#.  

### Пример использования

Чтобы скомпилировать проект, можно использовать команду `dotnet build` в командной строке, находясь в директории проекта. Этот файл конфигурирует процесс сборки таким образом, чтобы включить указанные исходные файлы и зависимости для создания исполняемого файла под целевую платформу .NET 8.0.

### Примеры программ (CodeSample)

Эти файлы в папке `CodeSample` содержат примеры кода, которые написаны на языке, поддерживаемом вашим компилятором. Они предназначены для тестирования и демонстрации возможностей компилятора и интерпретатора, который вы разрабатываете. Примеры кода показывают различные конструкции, такие как функции, рекурсия, условные операторы, операции с переменными и списками.

### Описание файлов и их сожержимого 

### Пример 1: Вычисление факториала (exp)

Этот файл содержит рекурсивную функцию для вычисления факториала числа `n` (функция `fact`). 
После определения функции, код вызывает её с аргументом `10` и выводит результат с помощью функции `print`. Пример демонстрирует рекурсивные функции и арифметические операции:

```fsharp
rec fun fact (n) {
    if n = 1 then {1}
    else {
        n * fact (n - 1)
    }
}
print(fact(10))
```

### Пример 2: Сравнение чисел (exp1)

Этот файл демонстрирует условные операторы. Он создает две переменные `x` и `y`, а затем сравнивает их. В зависимости от результата сравнения программа выводит либо `1`, либо `0`:

```fsharp
var x = 11
var y = 10

if x < y then {
    print(1)
} else {
    print(0)
}
```

### Пример 3: Проверка простого числа (exp2)

 Этот файл демонстрирует работу с рекурсией и условными операторами для проверки, является ли число простым. Вначале определяется вспомогательная функция `isPrimeHelper`, которая проверяет делимость числа. Затем объявляется функция `isPrime`, которая проверяет число с помощью вспомогательной функции. Пример демонстрирует использование рекурсии и логических операций:

```fsharp
rec fun isPrimeHelper(n i) {
    if i = 1 then {
        true
    } else {
        var left = n % i
        if left = 0 then {
            false
        } else {
            isPrimeHelper(n i - 1)
        }
    }
}

fun isPrime(n) {
    if n < 2 then {
        1
    } else {
        isPrimeHelper(n n - 1)
    }
}

var number = 4

print(isPrime(number))
```

### Пример 4: Демонстрация операторов (exp3)

Этот файл содержит несколько выражений, демонстрирующих операции сравнения, арифметические операции и работу со списками. Здесь используются операторы, такие как `<>` (неравенство), `=` (равенство), `<`, `>`, а также работа с переменными и списками:

```fsharp
print(1 <> 2)
print(1 = 2)
print(1 > 2)
print(1 < 1)
var a = 1
var b = 2
print(a + b)
print(1 + 1)
var lst = [1 2 3 true]
print(lst)
```

### Пример использования

Для использования примеров, можно запустить компилятор, передав один из файлов в качестве аргумента. Например:

```dotnet run exp```

Компилятор прочитает содержимое файла, скомпилирует его и выполнит соответствующие команды, выводя результат в консоль.

## .gitignore

Файл `.gitignore` содержит список файлов и папок, которые Git будет игнорировать при отслеживании изменений в репозитории. Это полезно, чтобы не добавлять в репозиторий ненужные или временные файлы, которые создаются во время разработки, сборки и работы IDE.

```
### DotnetCore ###
bin/
obj/

### fsharp ###
lib/debug
lib/release
Debug
*.suo
*.user
obj
bin

### VisualStudioCode ###
.vscode/*
.history/

### Windows ###
Thumbs.db
$RECYCLE.BIN/
*.lnk
```

### DotnetCore

Эта секция указывает, что Git должен игнорировать:  

Папки сборки .NET Core (`bin/`, `obj/`), где хранятся скомпилированные файлы.  
Папку `node_modules`, где находятся зависимости Node.js (если проект использует JavaScript).

Это важно, так как эти файлы автоматически генерируются во время сборки и не должны быть частью репозитория.

### fsharp

Эта секция относится к специфике F# проектов. Git будет игнорировать:  

Папки `lib/debug`, `lib/release`, `Debug`, `obj`, `bin`, где находятся временные файлы и результаты компиляции.  
Файлы настроек, такие как `.suo` и `.user`, которые специфичны для среды разработки.  
Папку `.fake`, которая используется для автоматизации с помощью FAKE (F# Make).  
Исключение: файл `.paket/paket.bootstrapper.exe` не будет игнорироваться, так как он может быть полезен для управления зависимостями через Paket.  

### VisualStudioCode

Эта секция относится к Visual Studio Code и указывает, что Git должен игнорировать:  

Настройки и файлы конфигурации внутри `.vscode/` (но некоторые из них, такие как `settings.json`, `tasks.json`, `launch.json`, могут быть полезными и не игнорируются).  
Папку `.history/`, которая используется для сохранения истории изменений.  
Файлы с расширением `.vsix`, которые являются скомпилированными расширениями для VS Code.  

### Windows

Эта секция игнорирует специфичные для Windows файлы, которые не нужны в репозитории:  

Файлы кеша миниатюр, такие как `Thumbs.db.`  
Файлы конфигурации рабочего стола, такие как `Desktop.ini.`  
Папку корзины `$RECYCLE.BIN/.`  
Файлы установщиков Windows, такие как `.cab`, `.msi`, `.msm`, и так далее.  
Ярлыки Windows с расширением `.lnk.`  



